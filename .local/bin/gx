#!/usr/bin/env bash

set -eu

# Cache directory and file
CACHE_DIR="${HOME}/.cache/gx"
CACHE_EXPIRY="5 minutes"

# Print usage
print_usage() {
  bin_name="$(basename $0)"
  echo "Usage:
  $bin_name [ login ] <installation> [ <separator> <cluster> ]  Create kubeconfig for the given installation or cluster
  $bin_name ssh <installation or cluster> <node>                SSH into the given node

Arguments:
  <installation>  installation name
  <cluster>       cluster name
  <node>          node name
  <separator>     any non alphanumeric character

Examples:
  $bin_name my-installation
  $bin_name my-installation my-cluster
  $bin_name ssh my-installation my-node
  $bin_name ssh my-cluster my-node"
}

echo_stderr() {
    >&2 echo "$@"
}

join_by() {
  local IFS="$1"
  shift
  echo "$*"
}

# Download and cache tsh data
tsh_cache() {
  tsh_cmd="$@"
  cache_name="$(join_by "_" $tsh_cmd)"
  cache_file="$CACHE_DIR/tsh_${cache_name}.json"

  mkdir -p "${CACHE_DIR}"
  expiry="$(date -d "- $CACHE_EXPIRY" +%s)"
  if [ ! -f "$cache_file" ] || [ "$(stat --printf=%Y "$cache_file")" -le "$expiry" ]; then
    echo_stderr "> Downloading tsh $tsh_cmd"
    tsh $tsh_cmd --format json > "$cache_file"
  fi

  cat "$cache_file"
}

create_kubeconfig() {
  # replace separator with space
  args=$(echo -n "$@" | sed -e 's/[^[:alnum:]]/ /1')

  # split words on spaces
  values=($args)

  # installation is always the first value
  installation="${values[0]}"
  cluster=""

  # context_match is used to filter kubectl contexts by regex
  context_matcher="${installation}$"
  # tsh_matcher is used to filter tsh clusters by name
  tsh_matcher="${installation}"

  # if there are more than 2 values, the last one is the cluster
  values_length=${#values[@]}
  if [ $values_length -ge 2 ]; then
    cluster="${values[$values_length-1]}"
    context_matcher="${installation}-${cluster}"
    tsh_matcher="${installation}-${cluster}"
  fi

  # Check if the kubectl context already exists
  if CONTEXTS=$(kubectl config get-contexts -oname | grep "${context_matcher}"); then
    echo_stderr "â–º Checking for existing kubectl contexts"
    for c in $CONTEXTS; do
      # Test if the context is valid and switch to it if it is
      timeout 5s kubectl --context "${c}" get nodes &>/dev/null && \
        kubectx "${c}" && \
        exit 0
      done
  fi

  # Check if the cluster exists in tsh
  tsh_ok="$(tsh_cache kube ls | jq '.[] | select(.kube_cluster_name == "'"$tsh_matcher"'") | true')"

  # use tsh or opsctl to login
  command=""
  if [ "$tsh_ok" == "true" ]; then
    command="tsh kube login "${tsh_matcher}""
  else
    command="opsctl login "${installation}" "${cluster}""
  fi

  (
    set -ex
    $command
  )
}

open_app() {
  installation="$1"
  app_name="$2"

  tsh_app_name="$(tsh_cache apps ls | jq -r '.[] | select(.metadata.labels["cluster"] == "'"$installation"'") | select(.metadata.labels["app"] == "'"$app_name"'") | .metadata.name')"
  if [ -n "$tsh_app_name" ]; then
    command="tsh app login ${tsh_app_name}"
  else
    command="opsctl open --app ${app_name} --installation ${installation}"
  fi

  (
    set -ex
    $command | tail -n 1 | xargs
  )

  #url=$(opsctl open --app "$2" --installation "$1" --no-browser)
  #echo "$url"
}

ssh_node() {
  # replace separator with space
  args=$(echo -n "$@" | sed -e 's/[^[:alnum:]]/ /1')

  # split words on spaces
  values=($args)

  # cluster is always the first value
  cluster_name="${values[0]}"
  node_name="${values[1]}"


  # Check if the node exists in tsh
  node_matcher="$(echo "${node_name}" | cut -d'.' -f1)"
  tsh_ok="$(tsh_cache ls | jq '.[] | select(.spec.hostname == "'"$node_matcher"'") | select(.metadata.labels["cluster"] == "'"$cluster_name"'") | true')"

  # use tsh or opsctl to ssh
  command=""
  if [ "$tsh_ok" == "true" ]; then
    command="tsh ssh root@cluster=${cluster_name},node=${node_matcher}"
  else
    command="opsctl ssh ${cluster_name} ${node_name}"
  fi

  (
    set -ex
    $command
  )
}

main() {
  # Require at least one argument
  if [ $# -lt 1 ] || [ "$1" == "-h" ]; then
    print_usage
    exit 0
  fi

  case "$1" in
    open)
      shift
      open_app "$@"
      ;;
    ssh)
      shift
      ssh_node "$@"
      ;;
    login)
      shift
      # fallthrough
      ;&
    *)
      create_kubeconfig "$@"
      ;;
  esac
}

main "$@"
